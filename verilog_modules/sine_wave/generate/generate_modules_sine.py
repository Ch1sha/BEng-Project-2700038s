import argparse
import concurrent.futures
import os
import math
import matplotlib.pyplot as plt
import numpy as np
import re
from skopt import gp_minimize
from skopt.space import Integer
from skopt.utils import use_named_args
from scipy.optimize import curve_fit
import matplotlib.cm as cm

# generate all modules in the verilog module root directory
MODULE_ROOT_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..')

## ============ half_sine_table.v generation ============
def generateSineTable(bitResolution:int, sampleCount:int) -> np.ndarray:
    """
    Generate a sine wave table with specified bit resolution and phase increment.

    :param bitResolution: The bit resolution for the output values. Default is 8 bits.
    :param sampleCount: The phase increment for generating the sine wave. Default is 100.
    :return: A numpy array containing the sine wave values scaled to fit the specified bit resolution.
    """

    amplitude=1 # DONT CHANGE THIS, need unitary amplitude for the sine wave
    # Frequency for the sine wave (1 Hz in this case, assuming normalized sampling)
    f = 1
    angularFreq = 2 * math.pi * f

    # Generate the sine wave table with values in the range [0, 2*amplitude]
    table = amplitude * np.array([math.sin(angularFreq * i / sampleCount) for i in range(int(-sampleCount/4), int(sampleCount/4))])

    # Scale to fit unsigned bit resolution, centred around amplitude
    max_val = (2 ** bitResolution) - 1  # Maximum value for the unsigned range
    table = np.round((table + 1) * (max_val / 2)).astype(int)  # Shifted and scaled
    return table

def construct_sine_table_module(sine_table: np.ndarray, bitResolution: int, filename='half_sine_table.v'):
    """
    Constructs a Verilog module for a sine wave table.

    This function generates a Verilog module that represents a sine wave table.
    The generated module includes an array of sine wave values and the size of the table.

    :param sine_table: List of integer values representing the sine wave.
    :param bitResolution: Integer representing the bit resolution of the sine wave values.
    :param filename: String representing the name of the output Verilog file. Default is 'half_sine_table.v'.
    """

    SINE_SIZE = bitResolution
    TABLE_SIZE = len(sine_table)
    TABLE_REG_SIZE = math.ceil(math.log2(TABLE_SIZE + 1))
    filepath = os.path.join(MODULE_ROOT_PATH, filename)

    with open(filepath, 'w') as file:
        file.write('//////////////////////////////////////////////////////////////////////////////////\n')
        file.write('// Module Name: half_sine_table\n')
        file.write('// Description: This module contains a lookup table for a half sine wave.\n')
        file.write('//              The table is parameterized by size and bit resolution.\n')
        file.write('//\n')
        file.write('// Autogenerated from generate_modules_sine.py\n')
        file.write('//////////////////////////////////////////////////////////////////////////////////\n\n')
        file.write('module half_sine_table #(\n')
        file.write('    parameter int SINE_SIZE = {},\n'.format(SINE_SIZE))
        file.write('    parameter int TABLE_SIZE = {},\n'.format(TABLE_SIZE))
        file.write('    parameter int TABLE_REG_SIZE = {}\n'.format(TABLE_REG_SIZE))
        file.write(') (\n')
        file.write('    output logic [SINE_SIZE-1:0] sine_wave [0:TABLE_SIZE-1],\n')
        file.write('    output logic [TABLE_REG_SIZE-1:0] table_size\n')
        file.write(');\n')
        file.write('    initial begin\n')
        file.write('        table_size = TABLE_SIZE-1;\n')
        for i, value in enumerate(sine_table):
            file.write('        sine_wave[{}] = {};\n'.format(i, value))
        file.write('    end\n')
        file.write('endmodule\n')

def optimise_sampleCount(bitCount, min_sample_val=None, max_sample_val=None, random_state=42, n_calls=100, n_initial_points=100):
    """
    Perform Bayesian optimisation to find the optimal sampleCount for a given bitcount.
    
    Parameters:
        n (int): Number of bits for amplitude resolution.
        m_min (int): Minimum value for `m` (default: 2n).
        m_max (int): Maximum value for `m` (default: 4 * 2^n).
        n_calls (int): Number of optimisation calls (default: 50).
        n_initial_points (int): Number of initial points for the optimisation (default: 10).
        random_state (int): Random seed for reproducibility (default: 42).
        
    Returns:
        dict: A dictionary containing the optimal `m`, the minimum loss, and optimisation results.
    """
    # Default range for sampleCount
    if min_sample_val is None:
        min_sample_val = bitCount*2
    if max_sample_val is None:
        max_sample_val = 4 * 2**bitCount

    # Define the search space for the sampleCount
    search_space = [Integer(min_sample_val, max_sample_val, name="sampleCount")]

    # Define the loss function
    def loss_function(bitCount, sampleCount):
        sine_table = generateSineTable(bitCount, sampleCount)
        unique_values = len(np.unique(sine_table))
        repeated_values = sampleCount - unique_values

        sampleCountWeight = 0.2
        repeatValueWeight = 0.4
        smoothnessWeight = 0.4
        max_value = (2 ** bitCount) - 1

        # Scaled penalty if the highest value is not achieved
        penalty = 1000 * (1 - (sine_table.max() / max_value))

        # Measure smoothness: lower std of differences is better
        smoothness_penalty = np.std(np.diff(sine_table))

        return (repeatValueWeight * repeated_values) - (sampleCountWeight * sampleCount) + + (smoothnessWeight * smoothness_penalty) + penalty

    # Define the objective function to wrap the loss function
    @use_named_args(search_space)
    def objective(**params):
        sampleCount = params["sampleCount"]
        return loss_function(bitCount, sampleCount)

    # Perform Bayesian optimisation
    result = gp_minimize(
        func=objective,
        dimensions=search_space,
        n_calls=n_calls,
        n_initial_points=n_initial_points,
        random_state=random_state, # Same seed for reproducibility
        verbose=False,
    )

    # Extract and return the results
    optimal_sampleCount = result.x[0]
    minimum_loss = result.fun

    return {
        "optimal_sampleCount": optimal_sampleCount,
        "minimum_loss": minimum_loss,
        "result": result,
    }


# ============ sine_wave.v generation ============ #

def update_sine_wave_macros(sine_table: np.ndarray, bitResolution: int, filename = 'sine_wave.v'):
    """
    Update the parameter definitions for the sine_wave.v module.

    :param sine_table: List of integer values representing the sine wave.
    :param bitResolution: Bit resolution for the sine wave values.
    :param filename: Path to the Verilog file to be updated.
    """

    SINE_SIZE = bitResolution
    TABLE_SIZE = len(sine_table)
    TABLE_REG_SIZE = math.ceil(math.log2(TABLE_SIZE + 1))
    file_path = os.path.join(MODULE_ROOT_PATH, filename)
    parameters = {"SINE_SIZE": SINE_SIZE, "TABLE_SIZE": TABLE_SIZE, "TABLE_REG_SIZE": TABLE_REG_SIZE}

    with open(file_path, 'r') as file:
        content = file.read()

    # Regex pattern to match Verilog parameters (e.g., parameter NAME = VALUE)
    pattern = r"parameter\s+int\s+(\w+)\s*=\s*(\d+)"

    def replacer(match):
        param_name = match.group(1)
        # Replace the parameter value if it's in the dictionary
        if param_name in parameters:
            new_value = parameters[param_name]
            return f"parameter int {param_name} = {new_value}"
        return match.group(0)  # Keep the original line if parameter not in dictionary

    # Replace parameters in the Verilog file
    updated_content = re.sub(pattern, replacer, content)

    # Overwrite the original file
    with open(file_path, 'w') as file:
        file.write(updated_content)


def plotSineWave(sine_table: np.ndarray):
    """
    Plots a sine wave using the provided sine table.

    :param sine_table: A numpy array containing the sine wave values to be plotted.
    :type sine_table: np.ndarray
    """

    plt.plot(sine_table)
    plt.title('Sine Wave')
    plt.xlabel('Samples')
    plt.ylabel('Sine Value')
    plt.grid(True)
    plt.show()

# ============ Ideal sampleCount ============ #

def find_ideal_sampleCount_data(maxBits=16):
    """
    Plot the ideal sample count data for a range of bit resolutions and fits the data to an exponential curve.
    This function calculates the optimal sample count for bit resolutions ranging from `minBits` to `maxBits` using 
    multithreading to speed up the computation. It then fits the calculated data to an exponential curve and plots 
    both the original data points and the fitted curve.
   
     Parameters:
    maxBits (int): The maximum bit resolution to consider. The default value is 16.
    Returns:
    None: It displays a plot of the data and the fitted curve.
    """
    minBits = 2

    def optimise_sampleCount_wrapper(bits):
        """
        Wrapper function to calculate the optimal sample count for a given bit resolution.
        """
        return bits, optimise_sampleCount(bits)["optimal_sampleCount"]
    
    def thread_done_callback(future):
        """
        Callback function to print the result of a threadn when it is done.
        """
        bits, optimal_sampleCount = future.result()
        print(f"Thread done for bits: {bits}, optimal_sampleCount: {optimal_sampleCount}")

    bitsToCycle = np.arange(minBits, maxBits+1)
    print(bitsToCycle)

    # Use ThreadPoolExecutor for multithreading
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(optimise_sampleCount_wrapper, bits) for bits in bitsToCycle]
        for future in futures:
            future.add_done_callback(thread_done_callback)

    # Collect the results
    results = [future.result() for future in futures]

    # Populate the dictionary with the results
    bit_idealSample_dict = {bits: optimal_sampleCount for bits, optimal_sampleCount in results}
    print(bit_idealSample_dict)
    idealSamples = list(bit_idealSample_dict.values())

    # === Now try to fit the data to a curve
    curve = lambda x, a, b, c : a * np.exp(b * x) + c
    #fit the data to the exponential curve
    params, covariance = curve_fit(curve, bitsToCycle, idealSamples)
    a, b, c = params
    print(f"Exponential fit (ae^(bx) +c): a={a}, b={b}, c={c}")
    # Generate smooth x values for plotting the fitted curve
    x_smooth = np.linspace(min(bitsToCycle), max(bitsToCycle), 500)
    y_smooth = curve(x_smooth, a, b, c)
    return bitsToCycle, idealSamples, params, x_smooth, y_smooth
    
def plot_ideal_sampleCount(bitsToCycle, idealSamples, params, x_smooth, y_smooth):
    # Plot the original data points
    plt.scatter(bitsToCycle, idealSamples, label="Data Points", color="blue", zorder=5)

    a, b, c = params
    # Plot the fitted exponential curve
    plt.plot(x_smooth, y_smooth, label=f"Fitted Curve: $y = {a:.2f}e^{{{b:.2f}x}} + {c:.2f}$", color="red", linewidth=2)

    # Add labels, legend, and title
    plt.xlabel('Bit Resolution')
    plt.ylabel('Ideal Sample Count')
    plt.title("Exponential Fit to Data")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()  # Adjust the padding between and around subplots
    plt.show()

def plot_multiple_sine_tables(max_bits, identicalSampleCount = None, wavesToPlot=None):
    """
    Generate and plot multiple sine tables for bit resolutions from 2 to max_bits.

    :param max_bits: The maximum bit resolution to consider.
    """
    plt.figure(figsize=(14, 10))
    colormap = cm.get_cmap('viridis', max_bits - 1)

    # First subplot: Linear scale
    plt.subplot(2, 1, 1)
    for bit_resolution in range(2, max_bits + 1):
        if wavesToPlot and bit_resolution not in wavesToPlot:
            continue
        sample_count = identicalSampleCount if identicalSampleCount else optimise_sampleCount(bit_resolution)["optimal_sampleCount"]
        sine_table = generateSineTable(bit_resolution, sample_count)
        sine_table_normalised = sine_table / np.max(sine_table)  # Scale to have a maximum value of 1
        color = colormap(bit_resolution - 2)
        plt.step(range(len(sine_table_normalised)), sine_table_normalised, label='{} bits'.format(bit_resolution), where='mid', color=color)
    
    title_part = "Identical Samples" if identicalSampleCount else "Optimal Samples"
    plt.title('Sine Tables for Different Bit Resolutions ({})'.format(title_part), fontsize=16)
    plt.xlabel('Samples', fontsize=12)
    plt.ylabel('Amplitude (Normalised)', fontsize=12)
    plt.legend()
    #plt.legend()
    plt.grid(True)

    # Second subplot: Logarithmic scale if identicalSampleCount is None
    if not identicalSampleCount:
        plt.subplot(2, 1, 2)
        for bit_resolution in range(2, max_bits + 1):
            if wavesToPlot and bit_resolution not in wavesToPlot:
                continue
            sample_count = optimise_sampleCount(bit_resolution)["optimal_sampleCount"]
            sine_table = generateSineTable(bit_resolution, sample_count)
            sine_table_normalised = sine_table / np.max(sine_table)  # Scale to have a maximum value of 1
            color = colormap(bit_resolution - 2)
            plt.step(range(len(sine_table_normalised)), sine_table_normalised, label='{} bits'.format(bit_resolution), where='mid', color=color)
        
        plt.xscale('log')
        plt.xlabel('Samples (Log Scale)', fontsize=12)
        plt.ylabel('Amplitude (Normalised)', fontsize=12)
        plt.legend()
        plt.grid(True)

    plt.tight_layout()  # Adjust the padding between and around subplots
    plt.show()


def main():
    parser = argparse.ArgumentParser(description='Generate a sine wave table.')
    parser.add_argument('--bit_count', type=int, default=8, help='The bit resolution for the sine wave values.')
    parser.add_argument('--override_sample', type=int, default=None, help='Override the sample count for the sine wave table.')
    parser.add_argument('--find_sample', type=int, default=None, help='Find the ideal sample count data, up to the specified bit resolution.')
    parser.add_argument('--plot_multiple', type=int, nargs='+', default=None, help='Plot multiple sine tables, x y z_1 z_2... where x is the max bits, y is the sample count (0 for ideal samples), and z_1 z_2... are the bit resolutions to plot.')
    parser.add_argument('--plot_sample', action='store_true', help='Plot the ideal sample count data.')
    parser.add_argument('--plot_sine', action='store_true', help='Plot the generated sine wave.')
    parser.add_argument('--no_generate', action='store_true', help='Do not generate and update the sine wave verilog modules.')
    args = parser.parse_args()

    bitResolution = args.bit_count
    override_sampleCount = args.override_sample
    find_sampleCounts = args.find_sample

    # determine the optimal sample count or use the override value
    if override_sampleCount:
        print("Overriding sample count with value: {}".format(override_sampleCount))
        sampleCount = override_sampleCount
    else:
        optimisation_results = optimise_sampleCount(bitResolution)
        sampleCount = optimisation_results["optimal_sampleCount"]
    deltaPhase = 360 / sampleCount

    if not args.no_generate:
        sine_table = generateSineTable(bitResolution=bitResolution, sampleCount=sampleCount)
        print("\nSine wave table generated with bit resolution = {}, delta phase = {}, and {} samples".format(bitResolution, deltaPhase, len(sine_table)))

        construct_sine_table_module(sine_table, bitResolution)
        print("half_sine_table.v generated with SINE_SIZE = {} and TABLE_SIZE = {}".format(bitResolution, len(sine_table)))

        update_sine_wave_macros(sine_table, bitResolution)
        print("sine_wave.v updated with SINE_SIZE = {} and TABLE_SIZE = {}\n".format(bitResolution, len(sine_table)))

    if args.plot_multiple:
        max_bits = args.plot_multiple[0]
        sample_count = args.plot_multiple[1] if len(args.plot_multiple) > 1 else None
        wavesToPlot = args.plot_multiple[2:] if len(args.plot_multiple) > 2 else None
        plot_multiple_sine_tables(max_bits, sample_count, wavesToPlot)

    if args.plot_sine:
        plotSineWave(sine_table)
    if find_sampleCounts:
        bitsToCycle, idealSamples, params, x_smooth, y_smooth = find_ideal_sampleCount_data(int(find_sampleCounts))
        if args.plot_sample:
            plot_ideal_sampleCount(bitsToCycle, idealSamples, params, x_smooth, y_smooth)

if __name__ == '__main__':
    main()
